// This code was generated by the Exception Handling WCF Proxy Generator add-in for Visual Studio 2008
// For updates and to view the supporting webcast go to http://wcfproxygenerator.codeplex.com
// Also go to http://wcfguidanceforwpf.codeplex.com for related whitepapers, webcasts and code samples

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Reflection;
using System.ServiceModel.Description;

namespace TodoList.WpfClient
{
    public abstract class ExceptionHandlingDuplexProxyBase<T, C> : ICommunicationObject, IDisposable
        where T : class
        where C : class
    {
        // state
        private bool IsOpened { get; set; }
        public bool IsDisposed { get; private set; }

        // locking
        private object m_channelLock = new object();
        private bool m_isInitialized = false;
        private bool m_isProxyCreated = false;
        private ManualResetEvent m_proxyRecreationLock = new ManualResetEvent(true);
        protected int m_proxyRecreationLockWait = 1000;

        // callback
        public C CallbackObject {get; private set; }

        // channel
        private DuplexChannelFactory<T> m_duplexChannelFactory = null;
        private T m_duplexChannel = default(T);

        #region Constructors and initialization

        public ExceptionHandlingDuplexProxyBase()
        {
        }

        public ExceptionHandlingDuplexProxyBase(C callbackObject, string endpointConfigurationName)
        {
            Initialize(callbackObject, endpointConfigurationName);
        }

        protected virtual void Initialize(C callbackObject, string endpointConfigurationName)
        {
            if (this.m_isInitialized) throw new InvalidOperationException("Object already initialized.");
            this.m_isInitialized = true;

            this.CallbackObject = callbackObject;
            m_duplexChannelFactory = new DuplexChannelFactory<T>(this.CallbackObject, endpointConfigurationName);
        }

        public ExceptionHandlingDuplexProxyBase(C callbackObject, string endpointConfigurationName, string remoteAddress)
        {
            Initialize(callbackObject, endpointConfigurationName, remoteAddress);
        }

        protected virtual void Initialize(C callbackObject, string endpointConfigurationName, string remoteAddress)
        {
            if (this.m_isInitialized) throw new InvalidOperationException("Object already initialized.");
            this.m_isInitialized = true;

            this.CallbackObject = callbackObject;
            m_duplexChannelFactory = new DuplexChannelFactory<T>(this.CallbackObject, endpointConfigurationName, new EndpointAddress(remoteAddress));

        }

        public ExceptionHandlingDuplexProxyBase(C callbackObject, Binding binding, EndpointAddress remoteAddress)
        {
            Initialize(callbackObject, binding, remoteAddress);

        }

        protected virtual void Initialize(C callbackObject, Binding binding, EndpointAddress remoteAddress)
        {
            if (this.m_isInitialized) throw new InvalidOperationException("Object already initialized.");
            this.m_isInitialized = true;

            this.CallbackObject = callbackObject;
            m_duplexChannelFactory = new DuplexChannelFactory<T>(this.CallbackObject, binding, remoteAddress);
        }

        #endregion

        #region Proxy creation

        public event EventHandler AfterRecreateProxy;

        protected virtual void CreateProxy()
        {
            lock (this.m_channelLock)
            {
                if (this.m_isProxyCreated) throw new InvalidOperationException("Proxy already created.");

                CreateInnerChannel(false);
                this.m_isProxyCreated = true;
            }
        }

        protected virtual void RecreateProxy()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                CreateInnerChannel(true);

                if (AfterRecreateProxy != null)
                    AfterRecreateProxy(this, null);
            }
        }

        private void CreateInnerChannel(bool recreateCallback)
        {
            lock (this.m_channelLock)
            {
                if (recreateCallback)
                    m_duplexChannel = m_duplexChannelFactory.CreateChannel(new InstanceContext(this.CallbackObject));
                else
                    m_duplexChannel = m_duplexChannelFactory.CreateChannel();

                ICommunicationObject co = m_duplexChannel as ICommunicationObject;
                co.Faulted += InnerChannel_Faulted;
                co.Closed += InnerChannel_Closed;
                co.Closing += InnerChannel_Closing;
                co.Opened += InnerChannel_Opened;
                co.Opening += InnerChannel_Opening;
            }
        }

        #endregion

        #region Communication events

        private void InnerChannel_Opening(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (this.Opening != null)
                    this.Opening(sender, e);
            }
        }

        private void InnerChannel_Opened(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (this.Opened != null)
                    this.Opened(sender, e);
            }
        }


        void InnerChannel_Closing(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (this.Closing != null)
                    this.Closing(sender, e);
            }
        }

        void InnerChannel_Closed(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                try
                {
                    this.m_proxyRecreationLock.Reset(); // will stop other threads from trying to Invoke() while recreating the proxy

                    if (this.Closed != null)
                        this.Closed(sender, e);

                    OnClosed();
                }
                finally
                {
                    this.m_proxyRecreationLock.Set(); // will stop other threads from trying to Invoke() while recreating the proxy
                }
            }
        }

        protected virtual void OnClosed()
        {

            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                this.Abort();
                RecreateProxy();
            }

        }

        private void InnerChannel_Faulted(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                try
                {
                    this.m_proxyRecreationLock.Reset(); // will stop other threads from trying to Invoke() while recreating the proxy

                    if (this.Faulted != null)
                        this.Faulted(sender, e);

                    OnFaulted();
                }
                finally
                {
                    this.m_proxyRecreationLock.Set(); // will stop other threads from trying to Invoke() while recreating the proxy
                }

            }
        }

        protected virtual void OnFaulted()
        {
            lock (m_channelLock)
            {

                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                this.Abort();
                RecreateProxy();
            }

        }
        #endregion

        # region Channel Properties
        public IDuplexContextChannel InnerDuplexChannel
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return (IDuplexContextChannel)m_duplexChannel;
            }
        }

        public ClientCredentials ClientCredentials
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return m_duplexChannelFactory.Credentials;
            }
        }

        public ServiceEndpoint Endpoint
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return m_duplexChannelFactory.Endpoint;
            }
        }

        public CommunicationState State
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                IChannel channel = (IChannel)m_duplexChannel;
                if (channel == null)
                    return CommunicationState.Created;

                return channel.State;
            }
        }

        #endregion

        #region ICommunicationObject Members

        public event EventHandler Faulted;
        public event EventHandler Closed;
        public event EventHandler Closing;
        public event EventHandler Opened;
        public event EventHandler Opening;


        public void Abort()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                ICommunicationObject co = (ICommunicationObject)m_duplexChannel;
                co.Closed -= new EventHandler(this.InnerChannel_Closed);
                co.Closing -= new EventHandler(this.InnerChannel_Closing);
                co.Faulted -= new EventHandler(this.InnerChannel_Faulted);
                co.Opened -= new EventHandler(this.InnerChannel_Opened);
                co.Opening -= new EventHandler(this.InnerChannel_Opening);
                co.Abort();
            }
        }


        public void Open(TimeSpan timeout)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");


                if (!this.IsOpened)
                {
                    EnsureProxy();
                    ((ICommunicationObject)m_duplexChannel).Open(timeout);
                    this.IsOpened = true;
                }
            }
        }

        public void Open()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (!this.IsOpened)
                {
                    EnsureProxy();
                    ((ICommunicationObject)m_duplexChannel).Open();
                    this.IsOpened = true;
                }
            }
        }


        public void Close(TimeSpan timeout)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_duplexChannel).Close(timeout);
            }
        }

        public void Close()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_duplexChannel).Close();
            }
        }

        public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_duplexChannel).BeginClose(timeout, callback, state);
            }
        }

        public IAsyncResult BeginClose(AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_duplexChannel).BeginClose(callback, state);
            }
        }

        public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_duplexChannel).BeginClose(timeout, callback, state);
            }
        }

        public IAsyncResult BeginOpen(AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_duplexChannel).BeginOpen(callback, state);
            }
        }

        public void EndClose(IAsyncResult result)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_duplexChannel).EndClose(result);
            }
        }

        public void EndOpen(IAsyncResult result)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_duplexChannel).EndOpen(result);
            }
        }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            lock (m_channelLock)
            {
                Cleanup();
                this.IsDisposed = true;
            }
        }

        protected virtual void Cleanup()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                try
                {
                    ICommunicationObject co = (ICommunicationObject)m_duplexChannel;
                    co.Closed -= InnerChannel_Closed;
                    co.Closing -= InnerChannel_Closing;
                    co.Faulted -= InnerChannel_Faulted;
                    co.Opened -= InnerChannel_Opened;
                    co.Opening -= InnerChannel_Opening;
                    co.Close();
                }
                catch
                {
                    try
                    {
                        ICommunicationObject co = (ICommunicationObject)m_duplexChannel;
                        co.Abort();
                    }
                    catch { }
                }

                try
                {
                    m_duplexChannelFactory.Close();
                }
                catch
                {
                    try
                    {
                        m_duplexChannelFactory.Abort();
                    }
                    catch { }
                }
            }
        }

        #endregion

        # region Invoke

        public delegate void RetryInvokeHandler(out Message unreadMessage);
        public event RetryInvokeHandler RetryInvoke;

        protected void Invoke(string operationName, params object[] parameters)
        {
            if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
            this.Open();

            MethodInfo methodInfo = GetMethod(operationName);

            try
            {
                // manual reset event here, turn it on when faulted
                // other threads will queue, and get a successful Invoke() once proxy is recreated
                this.m_proxyRecreationLock.WaitOne(this.m_proxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems
                methodInfo.Invoke(m_duplexChannel, parameters);
            }
            catch (TargetInvocationException targetEx) // Invoke() always throws this type
            {
                CommunicationException commEx = targetEx.InnerException as CommunicationException;
                if (commEx == null)
                {
                    throw targetEx.InnerException; // not a communication exception, throw it
                }

                FaultException faultEx = commEx as FaultException;
                if (faultEx != null)
                {
                    throw targetEx.InnerException; // the service threw a fault, throw it
                }

                try
                {
                    // manual reset event here, turn it on when faulted
                    // other threads will queue, and get a successful Invoke() once proxy is recreated
                    this.m_proxyRecreationLock.WaitOne(this.m_proxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems

                    // if it is a Message type it won't work, must fire RetryInvoke() and hopefully derived class will supply the original
                    // message to send again...
                    if (parameters.Length == 1 && parameters[0] is Message)
                    {
                        Message unreadMessage;
                        RetryInvoke(out unreadMessage);
                        methodInfo.Invoke(m_duplexChannel, new object[] { unreadMessage }); // a communication exception, retry once
                    }
                    else
                        methodInfo.Invoke(m_duplexChannel, parameters); // a communication exception, retry once
                }
                catch (TargetInvocationException targetEx2)
                {
                    throw targetEx2.InnerException; // still failed, throw it
                }
            }
        }

        protected TResult Invoke<TResult>(string operationName, params object[] parameters)
        {
            this.Open();

            MethodInfo methodInfo = GetMethod(operationName);
            TResult result = default(TResult);

            try
            {
                // manual reset event here, turn it on when faulted
                // other threads will queue, and get a successful Invoke() once proxy is recreated
                this.m_proxyRecreationLock.WaitOne(this.m_proxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems
                result = (TResult)methodInfo.Invoke(m_duplexChannel, parameters);
            }
            catch (TargetInvocationException targetEx) // Invoke() always throws this type
            {
                CommunicationException commEx = targetEx.InnerException as CommunicationException;
                if (commEx == null)
                {
                    throw targetEx.InnerException; // not a communication exception, throw it
                }

                FaultException faultEx = commEx as FaultException;
                if (faultEx != null)
                {
                    throw targetEx.InnerException; // the service threw a fault, throw it
                }

                // a communication exception, retry once
                try
                {
                    // manual reset event here, turn it on when faulted
                    // other threads will queue, and get a successful Invoke() once proxy is recreated
                    this.m_proxyRecreationLock.WaitOne(this.m_proxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems

                    if (parameters.Length == 1 && parameters[0] is Message)
                    {
                        Message unreadMessage;
                        RetryInvoke(out unreadMessage);
                        result = (TResult)methodInfo.Invoke(m_duplexChannel, new object[] { unreadMessage }); // communication exception, retry once
                    }
                    else
                        result = (TResult)methodInfo.Invoke(m_duplexChannel, parameters); // communication exception, retry once
                }
                catch (TargetInvocationException targetEx2)
                {
                    throw targetEx2.InnerException; // still failed, throw it
                }
            }

            return result;
        }


        private MethodInfo GetMethod(string operationName)
        {
            Type t = typeof(T);

            HashSet<MethodInfo> methods = new HashSet<MethodInfo>();
            GetMethodsRecursive(t, BindingFlags.Public | BindingFlags.Instance, ref methods);

            var result = from m in methods
                         where m.Name == operationName
                         select m;

            if (result.Count() == 0)
                throw new InvalidOperationException(String.Format("Unable to invoke method {0}. Method does not exist on contract {1}.", operationName, t.ToString()));

            if (result.Count() > 1)
                throw new InvalidOperationException(String.Format("Unable to invoke method {0}. More than one method is defined on contract {1} by the same name. Overloads not supported by ExceptionHandlingProxyBase.", operationName, t.ToString()));

            return result.First();
        }

        private void GetMethodsRecursive(Type t, BindingFlags flags, ref HashSet<MethodInfo> methods)
        {
            MethodInfo[] children = t.GetMethods(flags);
            methods.UnionWith(children);
            foreach (Type contract in t.GetInterfaces())
            {
                GetMethodsRecursive(contract, flags, ref methods);
            }
        }

        private void EnsureProxy()
        {
            lock (this.m_channelLock)
            {
                if (!this.m_isProxyCreated)
                {
                    this.CreateProxy();
                }
            }
        }

        #endregion

    }
}
